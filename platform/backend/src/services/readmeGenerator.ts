import fs from 'fs-extra';
import path from 'path';
import logger from '../utils/logger';

/**
 * README Generator
 *
 * Generates comprehensive README.md with:
 * - Architecture overview
 * - Technology stack
 * - Setup instructions
 * - How to run with docker-compose
 * - API documentation links
 * - Troubleshooting guide
 */

interface ProjectInfo {
  name: string;
  description: string;
  services: Array<{ name: string; port: number; description: string }>;
  microFrontends: Array<{ name: string; port: number; description: string }>;
  databases: string[];
  hasRedis: boolean;
  hasRabbitMQ: boolean;
  hasApiGateway: boolean;
}

export class ReadmeGenerator {

  async generateReadme(outputPath: string, projectInfo: ProjectInfo): Promise<void> {
    logger.info('Generating README.md');

    const readme = this.buildReadmeContent(projectInfo);

    await fs.writeFile(path.join(outputPath, 'README.md'), readme, 'utf-8');

    logger.info('README.md generated successfully');
  }

  private buildReadmeContent(info: ProjectInfo): string {
    return `# ${info.name}

${info.description}

**Generated by [Agent@Scale Platform](https://github.com/agent-scale) - Automated Migration from Monolith to Microservices & Micro-Frontends**

---

## üìã Table of Contents

- [Architecture Overview](#architecture-overview)
- [Technology Stack](#technology-stack)
- [Prerequisites](#prerequisites)
- [Quick Start](#quick-start)
- [Project Structure](#project-structure)
- [Services & Ports](#services--ports)
- [Development](#development)
- [API Documentation](#api-documentation)
- [Testing](#testing)
- [Deployment](#deployment)
- [Troubleshooting](#troubleshooting)

---

## üèóÔ∏è Architecture Overview

This project follows a **microservices architecture** with **micro-frontend pattern** using Module Federation.

### Backend Architecture

- **${info.services.length} Spring Boot Microservices** (Java 17, Spring Boot 3.2+)
- **Database per Service** pattern (PostgreSQL)
${info.hasApiGateway ? '- **API Gateway** (Spring Cloud Gateway) for routing and load balancing' : ''}
- **Service Discovery** (Eureka Server)
${info.hasRabbitMQ ? '- **Message Queue** (RabbitMQ) for asynchronous communication' : ''}
${info.hasRedis ? '- **Caching Layer** (Redis) for performance optimization' : ''}

### Frontend Architecture

- **${info.microFrontends.length} Angular Micro-Frontends** (Angular 17+)
- **Module Federation** (Webpack 5) for runtime integration
- **Shell Application** as host container
- **Standalone Components** (no NgModules)
- **Reactive Forms** with validation
- **JWT Authentication** with HTTP interceptors

---

## üõ†Ô∏è Technology Stack

### Backend

- **Framework:** Spring Boot 3.2.5
- **Language:** Java 17
- **Database:** PostgreSQL 15
- **ORM:** Spring Data JPA / Hibernate
- **Security:** Spring Security + JWT
- **API Docs:** SpringDoc OpenAPI (Swagger)
- **Build Tool:** Maven
- **Container:** Docker

### Frontend

- **Framework:** Angular 17+
- **Language:** TypeScript 5+
- **Module Federation:** Webpack 5
- **HTTP Client:** Angular HttpClient
- **Routing:** Angular Router with Guards
- **Forms:** Reactive Forms
- **Build Tool:** Angular CLI
- **Container:** Docker + Nginx

### Infrastructure

- **Containerization:** Docker
- **Orchestration:** Docker Compose (Development) / Kubernetes (Production)
${info.hasRedis ? '- **Cache:** Redis 7' : ''}
${info.hasRabbitMQ ? '- **Message Broker:** RabbitMQ 3' : ''}
- **Reverse Proxy:** Nginx

---

## ‚úÖ Prerequisites

Before running this application, ensure you have:

- **Docker** (v20.10+) and **Docker Compose** (v2.0+)
- **Git** for version control
- **(Optional) Java 17** and **Maven** for local development
- **(Optional) Node.js 20+** and **npm** for local frontend development

### Check installations:

\`\`\`bash
docker --version
docker-compose --version
git --version
\`\`\`

---

## üöÄ Quick Start

### Option 1: One-Command Startup (Recommended)

\`\`\`bash
# Make startup script executable
chmod +x start.sh

# Start everything
./start.sh
\`\`\`

### Option 2: Manual Docker Compose

\`\`\`bash
# Build and start all services
docker-compose up -d --build

# View logs
docker-compose logs -f

# Check service health
docker-compose ps
\`\`\`

### Option 3: Development Mode (Hot Reload)

\`\`\`bash
# Start with development overrides
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up --build
\`\`\`

---

## üìä Services & Ports

### Frontend Micro-Frontends

${info.microFrontends.map(mfe => `- **${this.formatName(mfe.name)}:** http://localhost:${mfe.port} - ${mfe.description}`).join('\n')}

### Backend Microservices

${info.services.map(svc => `- **${this.formatName(svc.name)}:** http://localhost:${svc.port} - ${svc.description}`).join('\n')}

${info.hasApiGateway ? `### API Gateway

- **API Gateway:** http://localhost:8080
- **Swagger UI:** http://localhost:8080/swagger-ui.html
` : ''}

### Databases

${info.databases.map((db, idx) => `- **PostgreSQL ${idx + 1}:** localhost:${5431 + idx} (Database: ${db})`).join('\n')}

${info.hasRedis ? `### Cache

- **Redis:** localhost:6379
` : ''}

${info.hasRabbitMQ ? `### Message Broker

- **RabbitMQ:** localhost:5672
- **RabbitMQ Management UI:** http://localhost:15672 (User: banque / Pass: banque123)
` : ''}

---

## üìÅ Project Structure

\`\`\`
${info.name}/
‚îú‚îÄ‚îÄ docker-compose.yml           # Production orchestration
‚îú‚îÄ‚îÄ docker-compose.dev.yml       # Development overrides
‚îú‚îÄ‚îÄ .env.example                 # Environment variables template
‚îú‚îÄ‚îÄ start.sh                     # Quick start script
‚îú‚îÄ‚îÄ stop.sh                      # Quick stop script
‚îú‚îÄ‚îÄ README.md                    # This file
‚îÇ
‚îú‚îÄ‚îÄ Frontend Micro-Frontends/
${info.microFrontends.map(mfe => `‚îÇ   ‚îú‚îÄ‚îÄ ${mfe.name}/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/                 # Source code
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile           # Production build
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ nginx.conf           # Nginx configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json         # Dependencies
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ webpack.config.js    # Module Federation config
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tsconfig.json        # TypeScript config`).join('\n‚îÇ   ‚îÇ\n')}
‚îÇ
‚îú‚îÄ‚îÄ Backend Microservices/
${info.services.map(svc => `‚îÇ   ‚îú‚îÄ‚îÄ ${svc.name}/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/main/java/       # Java source code
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/main/resources/  # Configuration files
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/test/            # Tests
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile           # Multi-stage build
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pom.xml              # Maven dependencies`).join('\n‚îÇ   ‚îÇ\n')}
${info.hasApiGateway ? `‚îÇ
‚îî‚îÄ‚îÄ api-gateway/                 # API Gateway (Spring Cloud Gateway)
    ‚îú‚îÄ‚îÄ src/
    ‚îú‚îÄ‚îÄ Dockerfile
    ‚îî‚îÄ‚îÄ pom.xml
` : ''}
\`\`\`

---

## üíª Development

### Running Services Individually

#### Backend Service (Example: auth-service)

\`\`\`bash
cd auth-service

# Start PostgreSQL database
docker-compose up -d postgres-auth-service

# Build and run service
mvn clean install
mvn spring-boot:run

# Or with Docker
docker build -t auth-service .
docker run -p 8081:8081 auth-service
\`\`\`

#### Frontend MFE (Example: shell-app)

\`\`\`bash
cd shell-app

# Install dependencies
npm install

# Start dev server
npm start

# Or with Docker
docker build -t shell-app .
docker run -p 4200:80 shell-app
\`\`\`

### Making Changes

1. **Backend Changes:** Modify code in \`src/main/java/\`, rebuild with \`mvn clean install\`
2. **Frontend Changes:** Modify code in \`src/app/\`, hot-reload active in dev mode
3. **Database Changes:** Update Flyway migrations in \`src/main/resources/db/migration/\`

---

## üìö API Documentation

### Swagger UI

Access interactive API documentation for each service:

${info.services.map(svc => `- **${this.formatName(svc.name)}:** http://localhost:${svc.port}/swagger-ui.html`).join('\n')}
${info.hasApiGateway ? `- **API Gateway (All APIs):** http://localhost:8080/swagger-ui.html` : ''}

### Sample API Requests

#### Authentication

\`\`\`bash
# Login
curl -X POST http://localhost:8081/api/auth/login \\
  -H "Content-Type: application/json" \\
  -d '{"username": "admin", "password": "admin123"}'

# Response: { "token": "eyJhbGc..." }
\`\`\`

#### Get User Profile

\`\`\`bash
curl -X GET http://localhost:8082/api/clients/me \\
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
\`\`\`

---

## üß™ Testing

### Run All Tests

\`\`\`bash
# Backend tests
cd auth-service
mvn test

# Frontend tests
cd shell-app
npm test

# E2E tests
npm run e2e
\`\`\`

### Test Coverage

- **Backend:** JUnit 5, Mockito, @SpringBootTest
- **Frontend:** Jasmine, Karma, Cypress
- **Integration:** TestContainers for database tests

---

## üåê Deployment

### Production Deployment (Kubernetes)

\`\`\`bash
# Build images for production
docker-compose build

# Tag and push to registry
docker tag auth-service your-registry.com/auth-service:latest
docker push your-registry.com/auth-service:latest

# Deploy to Kubernetes
kubectl apply -f k8s/

# Check deployment status
kubectl get pods
kubectl get services
\`\`\`

### Environment Variables

Copy \`.env.example\` to \`.env\` and configure:

\`\`\`bash
cp .env.example .env
# Edit .env with your production values
\`\`\`

---

## üêõ Troubleshooting

### Common Issues

#### 1. Port Already in Use

\`\`\`bash
# Find process using port
lsof -i :4200

# Kill process
kill -9 <PID>
\`\`\`

#### 2. Database Connection Failed

\`\`\`bash
# Check if database container is running
docker ps | grep postgres

# View database logs
docker-compose logs postgres-auth-service

# Restart database
docker-compose restart postgres-auth-service
\`\`\`

#### 3. Frontend Build Errors

\`\`\`bash
# Clean node_modules and reinstall
rm -rf node_modules package-lock.json
npm install

# Clear Angular cache
rm -rf .angular
\`\`\`

#### 4. Service Health Check Failing

\`\`\`bash
# Check service logs
docker-compose logs -f auth-service

# Check health endpoint
curl http://localhost:8081/actuator/health

# Restart service
docker-compose restart auth-service
\`\`\`

### Logs and Debugging

\`\`\`bash
# View all logs
docker-compose logs -f

# View specific service logs
docker-compose logs -f auth-service

# View last 100 lines
docker-compose logs --tail=100 auth-service

# Check container status
docker-compose ps
\`\`\`

### Clean Restart

\`\`\`bash
# Stop and remove everything
docker-compose down -v

# Remove all containers and volumes
docker system prune -a --volumes

# Rebuild and start fresh
docker-compose up -d --build
\`\`\`

---

## üìù Additional Documentation

- **Architecture Decisions:** See \`docs/architecture.md\`
- **API Contracts:** See \`docs/api-contracts.md\`
- **Security Guidelines:** See \`docs/security.md\`
- **Deployment Guide:** See \`docs/deployment.md\`

---

## üë• Support

For issues, questions, or contributions:

- **GitHub Issues:** [Report a bug or request a feature]
- **Email:** support@your-company.com
- **Docs:** [Full documentation]

---

## üìÑ License

Copyright ¬© ${new Date().getFullYear()} Your Company. All rights reserved.

---

**Generated by Agent@Scale Platform** ü§ñ
Automated migration from monolith to modern microservices architecture.
`;
  }

  private formatName(name: string): string {
    return name
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  /**
   * Generate architecture diagram documentation
   */
  async generateArchitectureDocs(outputPath: string, projectInfo: ProjectInfo): Promise<void> {
    const docsDir = path.join(outputPath, 'docs');
    await fs.ensureDir(docsDir);

    const archDoc = `# Architecture Documentation

## System Architecture

### Overview

This application follows a microservices architecture with micro-frontend pattern.

### Component Diagram

\`\`\`mermaid
graph TB
    subgraph "Frontend Layer"
        Shell[Shell App :4200]
        Auth[Auth MFE :4201]
        Dashboard[Dashboard MFE :4202]
        Transfers[Transfers MFE :4203]
        Cards[Cards MFE :4204]
    end

    subgraph "API Layer"
        Gateway[API Gateway :8080]
    end

    subgraph "Backend Layer"
${projectInfo.services.map(svc => `        ${svc.name}[${this.formatName(svc.name)} :${svc.port}]`).join('\n')}
    end

    subgraph "Data Layer"
${projectInfo.databases.map((db, idx) => `        DB${idx + 1}[(PostgreSQL ${idx + 1})]`).join('\n')}
${projectInfo.hasRedis ? '        Redis[(Redis Cache)]' : ''}
${projectInfo.hasRabbitMQ ? '        RabbitMQ[(RabbitMQ)]' : ''}
    end

    Shell --> Gateway
    Auth --> Gateway
    Dashboard --> Gateway
    Transfers --> Gateway
    Cards --> Gateway

    Gateway --> ${projectInfo.services[0]?.name || 'Services'}
${projectInfo.services.map((svc, idx) => `    Gateway --> ${svc.name}\n    ${svc.name} --> DB${idx + 1}`).join('\n')}
\`\`\`

### Micro-Frontend Architecture

Each micro-frontend is independently deployable and uses Module Federation for runtime integration.

### Backend Architecture

- **Service-oriented architecture** with domain-driven design
- **Database per service** for data isolation
- **Event-driven communication** via message queue
- **API Gateway** for unified entry point

---

Generated by Agent@Scale Platform
`;

    await fs.writeFile(path.join(docsDir, 'architecture.md'), archDoc, 'utf-8');
    logger.info('Architecture documentation generated');
  }
}

export default new ReadmeGenerator();
